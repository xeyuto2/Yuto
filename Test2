<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Yuto ULTRA Prediction ‚Äî Meta Sniper</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#000; --panel:#0b0b0b; --text:#e9e9e9; --muted:#9a9a9a; --border:#1e1e1e;
    --accentA:#00ffd5; --accentB:#2b6cff; --accentC:#ff3bd4;
  }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:20px;background:var(--bg);color:var(--text);font-family:Poppins,sans-serif}
  h1{margin:0 0 12px;text-align:center;font-weight:600;font-size:2rem;
     background:linear-gradient(135deg,var(--accentA),var(--accentB),var(--accentC));
     background-size:200% 200%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;
     animation:titleShift 6s ease infinite}
  label{display:block;text-align:center;margin-bottom:12px;color:var(--muted);font-weight:600}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;margin-top:18px;box-shadow:0 0 24px rgba(0,255,213,0.06);animation:fadeIn 400ms ease}
  .panel h3{margin:0 0 10px;font-weight:600}
  .entry{display:flex;gap:10px;align-items:center;margin-bottom:10px}
  input[type="number"]{width:94px;padding:10px 12px;border-radius:10px;background:#0f0f0f;color:var(--text);border:1px solid var(--border);outline:none;transition:border-color .2s,box-shadow .2s}
  input[type="number"]:focus{border-color:var(--accentB);box-shadow:0 0 0 4px rgba(43,108,255,.12)}
  .auto-info{font-size:13px;color:var(--muted)}
  button{background:linear-gradient(135deg,var(--accentA),var(--accentB));background-size:200% 200%;color:#061318;border:none;padding:10px 16px;border-radius:12px;font-weight:700;cursor:pointer;transition:transform .16s,box-shadow .2s,background-position .5s}
  button:hover{transform:translateY(-1px);box-shadow:0 8px 24px rgba(0,255,213,.22);background-position:100% 0}
  .btn-secondary{background:linear-gradient(135deg,#1b1b1b,#121212);color:var(--text);border:1px solid var(--border)}
  .btn-secondary:hover{box-shadow:0 6px 20px rgba(255,255,255,.06)}
  select{background:#0f0f0f;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px}
  .bar{background:#111;border-radius:8px;overflow:hidden;height:10px;margin-top:10px;border:1px solid #151515}
  .bar-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accentA),var(--accentB));transition:width .45s ease}
  #grid{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .cell{width:56px;height:56px;border-radius:10px;display:flex;align-items:center;justify-content:center;background:#070707;border:1px solid #141414;font-weight:700;font-size:14px;flex-direction:column}
  .score{font-size:11px;color:var(--muted);font-weight:600;margin-top:4px}
  .primary{outline:2px solid rgba(0,255,213,.12);box-shadow:0 6px 20px rgba(0,255,213,.06)}
  .top3{display:flex;gap:12px;justify-content:center;margin-top:10px}
  .top3 .card{padding:8px 12px;border-radius:10px;background:#090909;border:1px solid #141414;min-width:110px;text-align:center}
  pre.reason{white-space:pre-wrap;color:var(--muted);font-size:13px;margin-top:10px;max-height:320px;overflow:auto;background:transparent;border-left:1px solid #101010;padding-left:8px}
  .badge{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #1a1a1a;background:#0a0a0a;color:var(--muted);font-size:12px;margin-left:6px}
  @keyframes fadeIn{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}
  @keyframes titleShift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
  @media(max-width:600px){.entry{flex-direction:column;align-items:flex-start}input[type="number"]{width:100%}.cell{width:48px;height:48px}}
</style>
</head>
<body>

<h1>Yuto ULTRA Prediction üîÆ</h1>
<label><input type="checkbox" id="autoPredict"> Auto Predict</label>

<div id="inputs" class="panel">
  <h3>Enter latest numbers (0‚Äì9) ‚Äî newest last
    <span class="badge">Strategy:
      <select id="strategy">
        <option value="balanced" selected>Balanced</option>
        <option value="conservative">Conservative</option>
        <option value="aggressive">Aggressive</option>
      </select>
    </span>
  </h3>
  <div class="row" id="inputRows"></div>
  <div style="margin-top:12px" class="row">
    <button id="predictBtn" onclick="predict()">ULTRA Prediction</button>
    <button class="btn-secondary" onclick="clearInputs()">Clear</button>
    <button class="btn-secondary" onclick="loadSample()">Load Sample</button>
    <button class="btn-secondary" onclick="toggleSettings()">Settings</button>
  </div>
  <div id="settings" style="display:none;margin-top:10px;color:var(--muted);font-size:13px">
    <label><input type="checkbox" id="useAdaptive" checked> Use Adaptive Model Weighting</label>
    <label><input type="checkbox" id="useDynamicSelection" checked> Dynamic Model Selection</label>
    <label><input type="checkbox" id="useGameMechanics"> Game-specific tweaks (demo)</label>
  </div>
</div>

<div id="output" class="panel">
  <h3>üîÆ Result <span id="dqBadge" class="badge">Data Quality: ‚Äî</span></h3>
  <div id="primary"></div>
  <div class="top3" id="top3"></div>
  <div id="grid" aria-hidden="false"></div>
  <p id="confidence" style="text-align:center;margin-top:8px;color:var(--muted)"></p>
  <div class="bar"><div class="bar-fill" id="barFill"></div></div>
  <h3 style="margin-top:14px">üßæ Reasoning</h3>
  <pre class="reason" id="reasonText">No prediction yet.</pre>
</div>

<div class="panel" id="tracker">
  <h3>üìä Accuracy Tracker</h3>
  <p id="stats"><b>Total:</b> 0 | <b>Wins:</b> 0 | <b>Losses:</b> 0 | <b>Win Rate:</b> 0%</p>
  <div class="row">
    <button class="btn-secondary" onclick="markResult(true)">‚úÖ Win</button>
    <button class="btn-secondary" onclick="markResult(false)">‚ùå Loss</button>
    <button class="btn-secondary" onclick="resetLearning()">Reset Learning</button>
  </div>
</div>

<div class="panel" id="history">
  <h3>üìú Prediction History</h3>
  <div id="historyLog"></div>
  <div class="row" style="margin-top:8px">
    <button class="btn-secondary" onclick="exportHistory()">üìÅ Export History</button>
    <button class="btn-secondary" onclick="downloadCSV()">Download CSV</button>
  </div>
</div>

<script>
/* ---------- Basic helpers ---------- */
function getColor(num){ if(num===0||num===5) return "VIOLET"; if([2,4,6,8].includes(num)) return "RED"; return "GREEN"; }
function getSize(num){ return num>=5 ? "BIG":"SMALL"; }
function getParity(num){ return num%2===0 ? "EVEN":"ODD"; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function sum(a){ return a.reduce((x,y)=>x+y,0); }
function mean(a){ return a.length? sum(a)/a.length : 0; }
function entropy(p){ let e=0; for(const x of p){ if(x>0) e-= x*Math.log2(x);} return e; }
function indexOfMax(a){ return a.indexOf(Math.max(...a)); }

/* ---------- UI build ---------- */
const inputRows=document.getElementById('inputRows');
for(let i=0;i<10;i++){
  const el=document.createElement('div'); el.className='entry';
  el.innerHTML=`<input type="number" min="0" max="9" id="num${i}" placeholder="${(i+1)%10}" oninput="updateInfo(${i})">
                <div class="auto-info" id="info${i}">Color: ‚Äî | Size: ‚Äî</div>`;
  inputRows.appendChild(el);
}
function toggleSettings(){
  const s=document.getElementById('settings'); s.style.display = s.style.display==='none' ? 'block':'none';
}

/* ---------- State ---------- */
let historyData=[]; let lastPrediction=null; let total=0,wins=0,losses=0;
let modelAcc = JSON.parse(localStorage.getItem('yuto_model_acc')||'{}'); // {model:{wins,total}}
let overallAcc = JSON.parse(localStorage.getItem('yuto_overall_acc')||'{"wins":0,"total":0}');

/* ---------- Input helpers ---------- */
function updateInfo(i){
  const input=document.getElementById(`num${i}`); const val=parseInt(input.value); const info=document.getElementById(`info${i}`);
  if(isNaN(val)||val<0||val>9){ info.textContent="Color: ‚Äî | Size: ‚Äî"; input.style.borderColor="crimson"; return; }
  info.textContent=`Color: ${getColor(val)} | Size: ${getSize(val)}`; input.style.borderColor="var(--border)";
  // focus next empty
  for(let j=i+1;j<10;j++){ const ni=document.getElementById(`num${j}`); if(ni && ni.value===''){ ni.focus();break; } }
  if(document.getElementById('autoPredict').checked) predict();
}
function getEnteredHistory(){
  const arr=[]; for(let i=0;i<10;i++){ const v=document.getElementById(`num${i}`).value; if(v!=='') arr.push(parseInt(v)); }
  return arr;
}
function clearInputs(){
  for(let i=0;i<10;i++){ const el=document.getElementById(`num${i}`); if(el){ el.value=''; document.getElementById(`info${i}`).textContent="Color: ‚Äî | Size: ‚Äî"; el.style.borderColor="var(--border)"; } }
  document.getElementById('reasonText').textContent='Cleared inputs.';
}
function loadSample(){
  const sample=[3,1,4,1,5,9,2,6,5,3]; for(let i=0;i<10;i++){ document.getElementById(`num${i}`).value=sample[i]; updateInfo(i); }
}

/* ---------- Feature: Data Quality Assessment ---------- */
function assessDataQuality(nums){
  // randomness proxy: entropy of digit distribution + pattern strength (ngram repeats, streaks)
  const freq=Array(10).fill(0); nums.forEach(n=>freq[n]++);
  const totalDigits = nums.length || 1;
  const probs=freq.map(f=>f/totalDigits);
  const H=entropy(probs)/Math.log2(10); // 0..1
  // streak strength
  let maxStreak=1, cur=1; for(let i=1;i<nums.length;i++){ if(nums[i]===nums[i-1]) cur++; else { maxStreak=Math.max(maxStreak,cur); cur=1; } }
  const streakScore=clamp((maxStreak-1)/5,0,1); // up to 5+
  // ngram repeats
  let repeat2=0; for(let i=0;i+2<=nums.length-1;i++){ if(nums[i]===nums[i+2]) repeat2++; }
  const ngramStrength = clamp(repeat2/(nums.length||1),0,1);
  // low entropy + high pattern -> higher quality (more exploitable)
  const patternStrength = clamp((1-H)*0.6 + streakScore*0.25 + ngramStrength*0.15, 0, 1);
  // quality 0..1 (higher better for pattern finding)
  const quality = patternStrength;
  const label = quality>0.66?'High': quality>0.33?'Medium':'Low';
  return {quality,label,H,patternStrength,streak:maxStreak};
}

/* ---------- Core classic modules (from your previous build) ---------- */
function buildNgramCounts(nums,Nmax=6){ const counts={}; for(let n=2;n<=Nmax;n++){ counts[n]={};
  for(let i=0;i+n<nums.length;i++){ const key=nums.slice(i,i+n).join(','); const next=nums[i+n]; if(!counts[n][key]) counts[n][key]=Array(10).fill(0); counts[n][key][next]++; } }
  return counts; }
function exponentialNgramPredict(nums,Nmax=6){ const counts=buildNgramCounts(nums,Nmax); const scores=Array(10).fill(0);
  const last=nums.slice(Math.max(0,nums.length-Nmax));
  for(let n=Nmax;n>=2;n--){ const key=last.slice(last.length-n).join(','); if(key && counts[n] && counts[n][key]){ const arr=counts[n][key]; const t=sum(arr)||1; const w=Math.pow(2,n-2); for(let i=0;i<10;i++) scores[i]+= w*(arr[i]/t); } }
  return scores; }
function analyzeCycles(nums){ const s=Array(10).fill(0); const L=nums.length; if(L<4) return s; for(let p=1;p<=5;p++){ let m=0; for(let i=0;i+p<nums.length;i++){ if(nums[i]===nums[i+p]) m++; } if(m>=2){ const idx=nums.length-p; if(idx>=0){ const c=nums[idx]; s[c]+=1+m*0.6; } } } return s; }
function neuralLikeScores(nums){ const s=Array(10).fill(0); const L=nums.length;
  for(let len=2;len<=4;len++){ for(let i=0;i+len<=L-1;i++){ const pat=nums.slice(i,i+len).join(',');
    for(let j=i+1;j+len<=L-1;j++){ const p2=nums.slice(j,j+len).join(','); if(pat===p2){ s[nums[i+len]]+=0.6; s[nums[j+len]]+=0.6; } } } }
  const tailLen=Math.min(4,L-1); const tail=nums.slice(L-tailLen);
  for(let i=0;i+tailLen<=L-1;i++){ const cand=nums.slice(i,i+tailLen); let m=0; for(let k=0;k<tailLen;k++) if(cand[k]===tail[k]) m++; if(m>=Math.max(1,Math.floor(tailLen*0.6))){ s[nums[i+tailLen]]+=0.8*(m/tailLen); } }
  return s; }
function positionalPatterns(nums){
  const pos=Array(10).fill(0); const L=nums.length; if(L<3) return pos;
  for(let start=0;start<Math.min(4,L-1);start++){ const seq=[]; for(let i=start;i<L;i+=4) seq.push(nums[i]); if(seq.length>=2){ const diffs=[]; for(let i=1;i<seq.length;i++) diffs.push((seq[i]-seq[i-1]+10)%10); const d=Math.round(mean(diffs)); const cand=(seq[seq.length-1]+d)%10; pos[cand]+=1.2; } }
  const offsetCounts={}; for(let i=0;i<L;i++){ const k=`${i%4}:${nums[i]}`; offsetCounts[k]=(offsetCounts[k]||0)+1; }
  for(const k in offsetCounts){ const n=parseInt(k.split(':')[1]); pos[n]+=clamp(offsetCounts[k]*0.25,0,1.5); }
  return pos;
}
function frequencyAnalysis(nums){ const f=Array(10).fill(0); nums.forEach(n=>f[n]++); return f; }
function harmonicBalancing(freq){ const total=sum(freq)||1; const avg=total/10; const h=Array(10).fill(0); for(let i=0;i<10;i++){ const deficit=Math.max(0,avg-freq[i]); h[i]=1+(deficit/(avg+1))*0.8; } return h; }
function statisticalDeviationAnalysis(nums){ const f=frequencyAnalysis(nums); const avg=mean(f); const s=Array(10).fill(0); for(let i=0;i<10;i++){ const d=f[i]-avg; s[i]-=clamp(d*0.12,0,2.0);} return s; }
function gapAnalysis(nums){ const gaps=Array(10).fill(0), last=Array(10).fill(-1); for(let i=0;i<nums.length;i++){ const n=nums[i]; if(last[n]!==-1){ const g=i-last[n]; gaps[n]=gaps[n]? (gaps[n]+g)/2 : g; } last[n]=i; }
  const s=Array(10).fill(0); const avg=mean(gaps.filter(x=>x>0)); for(let i=0;i<10;i++){ if(gaps[i]>0){ const r=avg?gaps[i]/avg:1; if(r>1.1) s[i]+=clamp((r-1)*0.9,0,1.5); } else s[i]+=0.4; } return s; }
function hotColdAnalysis(nums){ const f=frequencyAnalysis(nums); const s=Array(10).fill(0); const mx=Math.max(...f); for(let i=0;i<10;i++){ const r=mx?f[i]/mx:0; s[i]+=clamp((1-r)*1.2,0,1.5);} return s; }
function buildTransitionMatrices(nums){
  const colorMap={},sizeMap={},parityMap={};
  for(let i=0;i<nums.length-1;i++){ const a=nums[i],b=nums[i+1]; const ca=getColor(a),cb=getColor(b); const sa=getSize(a),sb=getSize(b); const pa=getParity(a),pb=getParity(b);
    colorMap[ca]=colorMap[ca]||{}; colorMap[ca][cb]=(colorMap[ca][cb]||0)+1;
    sizeMap[sa]=sizeMap[sa]||{}; sizeMap[sa][sb]=(sizeMap[sa][sb]||0)+1;
    parityMap[pa]=parityMap[pa]||{}; parityMap[pa][pb]=(parityMap[pa][pb]||0)+1;
  }
  const colorToNums={'RED':[2,4,6,8,0,5],'GREEN':[1,3,7,9,0,5],'VIOLET':[0,5]};
  const sizeToNums={'BIG':[5,6,7,8,9],'SMALL':[0,1,2,3,4]};
  const s=Array(10).fill(0); const lastN=nums[nums.length-1]; const lastColor=getColor(lastN), lastSize=getSize(lastN), lastParity=getParity(lastN);
  function apply(map, state, mapping, w){ if(!map[state]) return; const t=sum(Object.values(map[state]));
    for(const k in map[state]){ const p=map[state][k]/(t||1); const cand=mapping[k]||[]; for(const c of cand) s[c]+= p*w/cand.length; } }
  apply(colorMap,lastColor,colorToNums,1.2); apply(sizeMap,lastSize,sizeToNums,1.0);
  if(parityMap[lastParity]){ const t=sum(Object.values(parityMap[lastParity]));
    for(const k in parityMap[lastParity]){ const p=parityMap[lastParity][k]/(t||1); for(let n=0;n<10;n++){ if(getParity(n)===k) s[n]+= p*0.6/5; } } }
  return s;
}
function positionalPatternsWrapper(nums){ return positionalPatterns(nums); }
function mathPatternScores(nums){
  const s=Array(10).fill(0);
  if(nums.length>=3){ const a=nums[nums.length-3],b=nums[nums.length-2],c=nums[nums.length-1];
    if(((a+b)%10)===c){ s[(b+c)%10]+=2.2; }
    const d1=(b-a+10)%10, d2=(c-b+10)%10;
    if(d1===d2) s[(c+d2)%10]+=1.8; else s[(c+Math.round((d1+d2)/2))%10]+=0.8;
    if(a!==0 && b!==0){ const r1=b/a, r2=c/b; if(Math.abs(r1-r2)<0.5){ const r=Math.round((r1+r2)/2); const cand=Math.round((c*r)%10); if(!isNaN(cand)) s[cand]+=1.2; } }
  }
  return s;
}
function chaosAttractorScores(nums){
  const s=Array(10).fill(0); const L=nums.length; if(L<4) return s; const win=4; const last=nums.slice(L-win);
  for(let i=0;i+win<=L-win;i++){ const w=nums.slice(i,i+win); let sim=0; for(let j=0;j<win;j++) if(w[j]===last[j]) sim++;
    if(sim>=3){ const idx=i+win; if(idx<nums.length){ const nx=nums[idx]; s[nx]+=1.3+(sim-3)*0.6; } }
    if(sim>=2){ const nx=nums[i+win]; if(nx!==undefined){ s[(nx+1)%10]+=0.4; s[(nx+9)%10]+=0.4; } }
  } return s;
}
function multiDimensionalState(nums){ const m=Array(10).fill(0); const t=buildTransitionMatrices(nums); for(let n=0;n<10;n++) m[n]+=t[n]||0; const p=positionalPatterns(nums); for(let n=0;n<10;n++) m[n]+=p[n]*0.8; return m; }
function antiClusteringScore(nums){ const s=Array(10).fill(0.5); for(let i=0;i<nums.length;i++){ const n=nums[i]; let rep=0; for(let j=Math.max(0,i-3); j<=Math.min(nums.length-1,i+3); j++){ if(j!==i && nums[j]===n) rep++; } s[n]-=clamp(rep*0.08,0,0.4); } return s; }
function infoGainAdjustment(raw){ const t=sum(raw)||1; const p=raw.map(x=>Math.max(0,x)/t); const e=entropy(p); const adj=p.map(v=>Math.pow(v+1e-9, 1+(1-(e/Math.log2(10)))*0.6)); const t2=sum(adj)||1; return adj.map(a=>a/t2); }
function calculateModelConsensus(scores){ const sorted=[...scores].map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s); const top=sorted.slice(0,3).map(x=>x.i); return 1-((scores[top[0]]-scores[top[1]])/(Math.max(...scores)||1)); }

/* ---------- NEW: Pattern Recognition Enhancement ---------- */
function analyzeAdvancedPatterns(nums){
  const s=Array(10).fill(0); const L=nums.length; if(L<3) return s;
  // mirror / palindrome detection
  const last3=nums.slice(-3); const last5=nums.slice(-5);
  if(last3[0]===last3[2]){ // aba
    const a=last3[0], b=last3[1]; s[(b+a)%10]+=1.0; // continue mirror trend loosely
  }
  if(L>=5 && last5[0]===last5[4] && last5[1]===last5[3]){ // abcba
    s[(last5[2]+last5[1])%10]+=1.0;
  }
  // ascending / descending streak
  let asc=0, desc=0; for(let i=L-1;i>=1;i--){ const d=(nums[i]-nums[i-1]+10)%10; if(d===1) asc++; else break; }
  for(let i=L-1;i>=1;i--){ const d=(nums[i-1]-nums[i]+10)%10; if(d===1) desc++; else break; }
  if(asc>=2) s[(nums[L-1]+1)%10]+=1.1; if(desc>=2) s[(nums[L-1]+9)%10]+=1.1;
  // even/odd alternation
  let alt=1; for(let i=L-1;i>=1;i--){ if(getParity(nums[i])!==getParity(nums[i-1])) alt++; else break; }
  if(alt>=3){ // continue alternation
    for(let n=0;n<10;n++){ if(getParity(n)!==getParity(nums[L-1])) s[n]+=0.5/5; }
  }
  // sum-based last 3
  if(L>=3){ const a=nums[L-3], b=nums[L-2], c=nums[L-1]; const cand=(a+b+c)%10; s[cand]+=0.8; }
  return s;
}

/* ---------- NEW: Time-Series Analysis ---------- */
function analyzeTrends(nums){
  const s=Array(10).fill(0); const L=nums.length; if(L<3) return s;
  // moving average (short & long)
  const sma = mean(nums.slice(-3)); const lma = mean(nums.slice(-6));
  const delta = ((sma - lma)+10)%10;
  s[Math.round((nums[L-1] + Math.round(delta))%10)] += 0.8;
  // momentum (last diffs)
  const d1=(nums[L-1]-nums[L-2]+10)%10; const d2=(nums[L-2]-nums[L-3]+10)%10;
  const mom = Math.round((d1*0.6 + d2*0.4))%10;
  s[(nums[L-1]+mom)%10] += 0.9;
  // seasonal-ish (position modulo 5)
  const idx=(L)%5; const bucketCounts={}; for(let i=idx;i<L;i+=5){ const n=nums[i]; bucketCounts[n]=(bucketCounts[n]||0)+1; }
  let best=-1,bscore=0; for(const k in bucketCounts){ if(bucketCounts[k]>bscore){ bscore=bucketCounts[k]; best=parseInt(k);} }
  if(best>=0) s[best]+=0.7;
  return s;
}

/* ---------- NEW: Game-Specific Learning (safe placeholder) ---------- */
function analyzeGameMechanics(nums){
  // Non-intrusive demo tweaks ‚Äî you can wire actual game rules here
  const s=Array(10).fill(0);
  const useGM=document.getElementById('useGameMechanics')?.checked;
  if(!useGM) return s;
  // Example: avoid repeating the exact last number too often (simulating anti-repeat bias)
  const last=nums[nums.length-1]; s[last]-=0.4;
  // Example: slight boost for 0 and 5 if they appear under-average (some games treat 0/5 special)
  const f=frequencyAnalysis(nums); const avg=mean(f);
  if(f[0]<avg) s[0]+=0.3; if(f[5]<avg) s[5]+=0.3;
  return s;
}

/* ---------- NEW: Streak Patterns ---------- */
function analyzeStreakPatterns(nums){
  const s=Array(10).fill(0); const L=nums.length; if(L<2) return s;
  // number streak
  let count=1; for(let i=L-1;i>=1;i--){ if(nums[i]===nums[i-1]) count++; else break; }
  if(count>=2){ // continuation vs break
    s[nums[L-1]] += 0.6 * Math.min(count,4); // continue
    s[(nums[L-1]+1)%10] += 0.3; s[(nums[L-1]+9)%10] += 0.3; // break neighbors
  }
  // color streak
  let cst=1; for(let i=L-1;i>=1;i--){ if(getColor(nums[i])===getColor(nums[i-1])) cst++; else break; }
  if(cst>=3){ // streak likely to break
    for(let n=0;n<10;n++){ if(getColor(n)!==getColor(nums[L-1])) s[n]+=0.5/8; }
  }
  return s;
}

/* ---------- NEW: Weighted Ensemble Learning ---------- */
function adaptiveModelWeighting(predContrib, recentAcc){
  // predContrib: {modelName: perNumberScoreArray}
  // recentAcc:   {modelName:{wins,total}}
  // Output: weight multipliers per model (default 1)
  const weights={}; const names=Object.keys(predContrib);
  let maxRate=0;
  for(const name of names){
    const rec=recentAcc[name]||{wins:0,total:0};
    const rate = rec.total ? rec.wins/rec.total : 0.5; // default neutral
    maxRate=Math.max(maxRate, rate);
    weights[name]=0.6 + rate*0.8; // 0.6 .. 1.4
  }
  // normalize relative to best performing model
  if(maxRate>0){ for(const k of names){ weights[k] = weights[k] * (0.9 + 0.2*( (recentAcc[k]?.wins/(recentAcc[k]?.total||1)) / maxRate )); } }
  return weights;
}

/* ---------- NEW: Confidence Calibration ---------- */
function calibrateConfidence(probs, historicalAccuracy, modelAgreement, dataQuality){
  // probs: normalized per-number probabilities
  const top = [...probs].sort((a,b)=>b-a).slice(0,3);
  const spread = top[0] - (top[1]||0);
  const prior = historicalAccuracy.total ? (historicalAccuracy.wins/historicalAccuracy.total) : 0.55;
  // Bayesian-ish: posterior ~ topProb weighted by prior & agreement
  const base = 70 + (top[0]*25) + (spread*10);
  const agreeBoost = modelAgreement*8;
  const priorBoost = (prior-0.5)*20;
  const qualityBoost = (dataQuality.quality-0.5)*18;
  return clamp(base + agreeBoost + priorBoost + qualityBoost, 65, 95);
}

/* ---------- NEW: Time & Cross-Validation ---------- */
function validateModels(historicalSeq){
  // simple sliding-window: for each position, pretend we had up to that point
  // and check which model would have put actual next in its top-3
  if(historicalSeq.length<15) return null;
  const acc={}; // name -> {wins,total}
  function bump(name,win){ acc[name]=acc[name]||{wins:0,total:0}; acc[name].total++; if(win) acc[name].wins++; }
  for(let k=10;k<historicalSeq.length-1;k++){
    const window = historicalSeq.slice(0,k);
    const models = computeModelContrib(window); // {name: scores[10]}
    const next = historicalSeq[k];
    for(const name in models){
      const arr=models[name]; const ranked=[...arr].map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s).slice(0,3).map(x=>x.i);
      bump(name, ranked.includes(next));
    }
  }
  return acc;
}

/* ---------- NEW: Trend & Advanced patterns wrappers ---------- */
function analyzeTrendsWrapper(nums){ return analyzeTrends(nums); }
function analyzeAdvancedPatternsWrapper(nums){ return analyzeAdvancedPatterns(nums); }

/* ---------- Model contribution calculator (for adaptive weighting & validation) ---------- */
function computeModelContrib(nums){
  return {
    NGRAM: exponentialNgramPredict(nums,6),
    CYCLES: analyzeCycles(nums),
    NEURAL: neuralLikeScores(nums),
    POSITIONAL: positionalPatternsWrapper(nums),
    STAT_DEV: statisticalDeviationAnalysis(nums),
    GAP: gapAnalysis(nums),
    HOTCOLD: hotColdAnalysis(nums),
    TRANSITIONS: buildTransitionMatrices(nums),
    MATH: mathPatternScores(nums),
    CHAOS: chaosAttractorScores(nums),
    MULTIDIM: multiDimensionalState(nums),
    ADVANCED: analyzeAdvancedPatternsWrapper(nums),
    TRENDS: analyzeTrendsWrapper(nums),
    STREAKS: analyzeStreakPatterns(nums),
    GAME: analyzeGameMechanics(nums)
  };
}

/* ---------- Dynamic Model Selection ---------- */
function selectModels(models, dataQuality){
  const selected={};
  const dq = dataQuality.quality;
  for(const name in models){
    // base keep
    let keep=true;
    // If data quality is low, prefer robust models; drop fragile ones
    if(dq<0.33 && ['CHAOS','NEURAL','ADVANCED'].includes(name)) keep=false;
    // If extremely short sequences, drop heavy models
    if(models[name].every(x=>x===0)) keep=false;
    if(keep) selected[name]=models[name];
  }
  return selected;
}

/* ---------- Prediction main ---------- */
function predict(){
  const raw=getEnteredHistory();
  const primaryBox=document.getElementById('primary');
  const grid=document.getElementById('grid');
  const strategy = document.getElementById('strategy').value;

  if(raw.length<3){ primaryBox.innerHTML="<b>Please enter at least 3 numbers.</b>"; document.getElementById('reasonText').textContent="Need at least 3 inputs."; return; }

  const nums=raw.slice();
  const dataQ=assessDataQuality(nums);
  document.getElementById('dqBadge').textContent = `Data Quality: ${dataQ.label}`;

  // Get per-model raw contributions
  let models = computeModelContrib(nums);

  // Dynamic selection (optional)
  if(document.getElementById('useDynamicSelection')?.checked){
    models = selectModels(models, dataQ);
  }

  // Base weights
  let baseWeights={
    NGRAM:2.6, CYCLES:1.8, NEURAL:1.6, POSITIONAL:1.6, STAT_DEV:1.2, GAP:1.4, HOTCOLD:1.1,
    TRANSITIONS:1.8, MATH:1.5, CHAOS:1.2, MULTIDIM:1.8, ADVANCED:1.7, TRENDS:1.5, STREAKS:1.4, GAME:1.0
  };

  // Strategy tweaks
  if(strategy==='conservative'){
    baseWeights = Object.fromEntries(Object.entries(baseWeights).map(([k,v])=>[k,
      v * (['NGRAM','TRANSITIONS','POSITIONAL','MULTIDIM','STAT_DEV'].includes(k)?1.2:0.8)
    ]));
  } else if(strategy==='aggressive'){
    baseWeights = Object.fromEntries(Object.entries(baseWeights).map(([k,v])=>[k,
      v * (['CHAOS','NEURAL','ADVANCED','TRENDS','STREAKS','HOTCOLD'].includes(k)?1.25:0.9)
    ]));
  }

  // Adaptive weights by recent accuracy
  let adaptMultipliers = {};
  if(document.getElementById('useAdaptive')?.checked){
    adaptMultipliers = adaptiveModelWeighting(models, modelAcc);
  } else {
    for(const k in models) adaptMultipliers[k]=1;
  }

  // Ensemble aggregation
  let aggregate=Array(10).fill(0);
  const reasonLines=[];
  for(const name in models){
    const w = (baseWeights[name]||1) * (adaptMultipliers[name]||1);
    const arr=models[name];
    for(let i=0;i<10;i++) aggregate[i]+= (arr[i]||0)*w;
    reasonLines.push(`${name}: weight ${w.toFixed(2)}`);
  }

  // Harmonic balancing & anti-clustering multiplicative factors
  const harmonic = harmonicBalancing(frequencyAnalysis(nums));
  const anti = antiClusteringScore(nums);
  for(let i=0;i<10;i++){ aggregate[i] = Math.max(0, aggregate[i]) * harmonic[i] * anti[i]; }

  // Normalize via information theory
  const probs = infoGainAdjustment(aggregate);
  const consensus = calculateModelConsensus(aggregate);

  // Confidence calibration (Bayesian-ish)
  const confidence = calibrateConfidence(probs, overallAcc, consensus, dataQ);

  // Top-3
  const ranked = probs.map((p,i)=>({i,p})).sort((a,b)=>b.p-a.p);
  const top3 = ranked.slice(0,3);
  const bestNum = top3[0].i;

  // UI render
  document.getElementById('primary').innerHTML =
    `<p style="text-align:center;font-size:18px;margin:6px 0;">
       <b>Primary Number:</b> <span style="font-size:20px">${bestNum}</span>
       <span class="badge">${strategy}</span>
     </p>
     <p style="text-align:center;"><b>Color:</b> ${getColor(bestNum)} | <b>Size:</b> ${getSize(bestNum)} | <b>Parity:</b> ${getParity(bestNum)}</p>`;
  const top3Div=document.getElementById('top3'); top3Div.innerHTML='';
  for(const t of top3){ top3Div.innerHTML += `<div class="card"><div style="font-size:18px">${t.i}</div><div class="score">${(t.p*100).toFixed(2)}%</div></div>`; }
  grid.innerHTML=''; for(let n=0;n<10;n++){ const el=document.createElement('div'); el.className='cell'+(n===bestNum?' primary':''); el.innerHTML=`<div>${n}</div><div class="score">${(probs[n]*100).toFixed(1)}%</div>`; grid.appendChild(el); }

  // Reasoning block
  const reasonsDetailed=[];
  reasonsDetailed.push(`Inputs (${nums.length}): ${nums.join(', ')}`);
  reasonsDetailed.push(`Top 3: ${top3.map(t=>`${t.i} (${(t.p*100).toFixed(2)}%)`).join(' | ')}`);
  reasonsDetailed.push(`Confidence: ${confidence.toFixed(1)}%  |  Consensus: ${consensus.toFixed(3)}  |  DataQ: ${dataQ.label} (H=${dataQ.H.toFixed(2)}, pattern=${dataQ.patternStrength.toFixed(2)})`);
  reasonsDetailed.push('');
  reasonsDetailed.push('Model weights:'); reasonsDetailed.push(...reasonLines);
  const ngramTop = models.NGRAM ? models.NGRAM.map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s)[0] : null;
  if(ngramTop && ngramTop.s>0) reasonsDetailed.push(`‚Ä¢ N-gram suggests ${ngramTop.i}`);
  const trendTop = models.TRENDS ? models.TRENDS.map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s)[0] : null;
  if(trendTop && trendTop.s>0) reasonsDetailed.push(`‚Ä¢ Trend points to ${trendTop.i}`);
  const advTop = models.ADVANCED ? models.ADVANCED.map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s)[0] : null;
  if(advTop && advTop.s>0) reasonsDetailed.push(`‚Ä¢ Advanced patterns favor ${advTop.i}`);
  document.getElementById('reasonText').textContent = reasonsDetailed.join('\n');

  document.getElementById('confidence').textContent = `Confidence: ${confidence.toFixed(1)}%`;
  document.getElementById('barFill').style.width = `${confidence}%`;

  // Save history entry with per-model suggestions for learning
  const entry = {
    timestamp:new Date().toISOString(),
    inputs:nums.join(','), primary:bestNum, top3:top3.map(t=>t.i).join(','),
    probs:probs.map(p=>p.toFixed(4)).join(';'), confidence:confidence.toFixed(1),
    strategy, modelsTop: Object.fromEntries(Object.entries(models).map(([k,v])=>{
      const idx=[...v].map((s,i)=>({i,s})).sort((a,b)=>b.s-a.s).slice(0,3).map(x=>x.i);
      return [k, idx];
    }))
  };
  historyData.push(entry); updateHistory();
  lastPrediction = { number:bestNum, probs, confidence, modelsTop:entry.modelsTop };
}

/* ---------- Learning from results ---------- */
function markResult(win){
  if(!lastPrediction || !historyData.length) return;
  total++; if(win) wins++; else losses++;
  const rate=((wins/total)*100).toFixed(2);
  document.getElementById('stats').innerHTML=`<b>Total:</b> ${total} | <b>Wins:</b> ${wins} | <b>Losses:</b> ${losses} | <b>Win Rate:</b> ${rate}%`;
  // update last history with outcome
  historyData[historyData.length-1].outcome = win ? 'WIN':'LOSS';
  // Update per-model accuracy: if actual outcome matches model's top3
  const actual = prompt('Enter actual result number (0-9):', '');
  const val = actual===null? null : parseInt(actual);
  if(val!==null && !isNaN(val) && val>=0 && val<=9){
    const latest = historyData[historyData.length-1];
    for(const name in latest.modelsTop){
      const hit = latest.modelsTop[name].includes(val);
      modelAcc[name]=modelAcc[name]||{wins:0,total:0};
      modelAcc[name].total++; if(hit) modelAcc[name].wins++;
    }
    overallAcc.total++; if(win) overallAcc.wins++;
    localStorage.setItem('yuto_model_acc', JSON.stringify(modelAcc));
    localStorage.setItem('yuto_overall_acc', JSON.stringify(overallAcc));
  }
  updateHistory();
}
function resetLearning(){
  modelAcc={}; overallAcc={wins:0,total:0}; localStorage.removeItem('yuto_model_acc'); localStorage.removeItem('yuto_overall_acc');
  alert('Adaptive learning reset.');
}

/* ---------- History & export ---------- */
function updateHistory(){
  const log=document.getElementById('historyLog'); log.innerHTML='';
  historyData.slice(-20).reverse().forEach(h=>{
    const el=document.createElement('div'); el.style.padding='6px 0'; el.style.borderBottom='1px solid #101010';
    el.innerHTML = `<div><b>${h.primary}</b> [${h.top3}] ‚Äî ${h.confidence}% ‚Äî ${h.timestamp.split('T')[0]} ${h.timestamp.split('T')[1].split('.')[0]} ${h.outcome? ' | '+h.outcome:''}</div>
                    <div style="color:var(--muted);font-size:12px">in:${h.inputs}</div>`;
    log.appendChild(el);
  });
}
function exportHistory(){
  let csv="timestamp,inputs,primary,top3,probs,confidence,strategy,outcome\n";
  for(const h of historyData){ csv+=`"${h.timestamp}","${h.inputs}",${h.primary},"${h.top3}","${h.probs}",${h.confidence},"${h.strategy||''}","${h.outcome||''}"\n`; }
  const blob=new Blob([csv],{type:'text/csv'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='yuto_ultra_history.csv'; a.click(); URL.revokeObjectURL(url);
}
function downloadCSV(){ exportHistory(); }

/* ---------- Keyboard: Enter to predict ---------- */
document.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ const f=document.activeElement; if(f && f.tagName==='INPUT') predict(); }});
</script>
</body>
</html>
